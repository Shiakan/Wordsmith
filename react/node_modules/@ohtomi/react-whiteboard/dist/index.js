(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactWhiteboard"] = factory(require("react"));
	else
		root["ReactWhiteboard"] = factory(root["react"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var MODE = exports.MODE = {
    HAND: 'HAND',
    DRAW_LINE: 'DRAW_LINE',
    DRAG_IMAGE: 'DRAG_IMAGE',
    NW_RESIZE_IMAGE: 'NW_RESIZE_IMAGE',
    NE_RESIZE_IMAGE: 'NE_RESIZE_IMAGE',
    SE_RESIZE_IMAGE: 'SE_RESIZE_IMAGE',
    SW_RESIZE_IMAGE: 'SW_RESIZE_IMAGE'
};

var SVG_ELEMENT_TYPE = exports.SVG_ELEMENT_TYPE = {
    LINE: 'LINE',
    IMAGE: 'IMAGE'
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Constants = __webpack_require__(0);

var Constants = _interopRequireWildcard(_Constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventStore = function () {
    function EventStore() {
        _classCallCheck(this, EventStore);

        this.selectedLayer = 0;
        this.renderableLayers = [true];
        this.goodEvents = [];
        this.undoEvents = [];
    }

    _createClass(EventStore, [{
        key: 'lastImage',
        value: function lastImage() {
            var last = this.goodEvents[this.goodEvents.length - 1];
            if (last && last.type === Constants.SVG_ELEMENT_TYPE.IMAGE) {
                return last.image;
            } else {
                return null;
            }
        }
    }, {
        key: 'reduceEvents',
        value: function reduceEvents() {
            var _this = this;

            return this.goodEvents.reduce(function (prev, element) {
                if (!element.type) {
                    prev.forEach(function (p) {
                        p.push({});
                    });
                    return prev;
                }

                if (element.type === Constants.SVG_ELEMENT_TYPE.LINE) {
                    var last = prev[element.layer][prev[element.layer].length - 1];
                    if (last && last.type === Constants.SVG_ELEMENT_TYPE.LINE && last.strokeWidth === element.strokeWidth && last.strokeColor === element.strokeColor) {
                        last.values.push(element.point);
                    } else {
                        var event = {
                            type: element.type,
                            strokeWidth: element.strokeWidth,
                            strokeColor: element.strokeColor,
                            values: [element.point]
                        };
                        prev[element.layer].push(event);
                    }
                    return prev;
                } else if (element.type === Constants.SVG_ELEMENT_TYPE.IMAGE) {
                    var _event = {
                        type: element.type,
                        image: element.image
                    };
                    prev[element.layer].push(_event);
                    return prev;
                } else {
                    return prev;
                }
            }, this.renderableLayers.map(function () {
                return [];
            })).filter(function (element, index) {
                return _this.renderableLayers[index];
            }).reduce(function (prev, element) {
                return prev.concat(element);
            }, []).filter(function (element) {
                if (element.type === Constants.SVG_ELEMENT_TYPE.LINE) {
                    return element.values.length > 1;
                } else if (element.type === Constants.SVG_ELEMENT_TYPE.IMAGE) {
                    return true;
                } else {
                    return true;
                }
            });
        }
    }, {
        key: 'selectLayer',
        value: function selectLayer(layer) {
            this.goodEvents.push({});
            this.selectedLayer = layer;
        }
    }, {
        key: 'addLayer',
        value: function addLayer() {
            this.renderableLayers.push(true);
        }
    }, {
        key: 'startDrawing',
        value: function startDrawing(strokeWidth, strokeColor, point) {
            this.goodEvents.push({
                type: Constants.SVG_ELEMENT_TYPE.LINE,
                layer: this.selectedLayer,
                strokeWidth: strokeWidth,
                strokeColor: strokeColor,
                point: point
            });
        }
    }, {
        key: 'stopDrawing',
        value: function stopDrawing() {
            this.goodEvents.push({});
        }
    }, {
        key: 'pushPoint',
        value: function pushPoint(strokeWidth, strokeColor, point) {
            var event = {
                type: Constants.SVG_ELEMENT_TYPE.LINE,
                layer: this.selectedLayer,
                strokeWidth: strokeWidth,
                strokeColor: strokeColor,
                point: point
            };
            this.goodEvents.push(event);
            this.undoEvents = [];
        }
    }, {
        key: 'pasteImage',
        value: function pasteImage(image) {
            var event = {
                type: Constants.SVG_ELEMENT_TYPE.IMAGE,
                layer: this.selectedLayer,
                image: image
            };
            this.goodEvents.push(event);
            this.undoEvents = [];
        }
    }, {
        key: 'dragImage',
        value: function dragImage(move) {
            var lastImage = this.lastImage();
            if (lastImage) {
                lastImage.x = lastImage.x + move.x;
                lastImage.y = lastImage.y + move.y;
            }
        }
    }, {
        key: 'nwResizeImage',
        value: function nwResizeImage(move) {
            var lastImage = this.lastImage();
            if (lastImage) {
                lastImage.x = lastImage.x + move.x;
                lastImage.y = lastImage.y + move.y;
                lastImage.width = lastImage.width - move.x;
                lastImage.height = lastImage.height - move.y;
            }
        }
    }, {
        key: 'neResizeImage',
        value: function neResizeImage(move) {
            var lastImage = this.lastImage();
            if (lastImage) {
                // lastImage.x = lastImage.x + move.x;
                lastImage.y = lastImage.y + move.y;
                lastImage.width = lastImage.width + move.x;
                lastImage.height = lastImage.height - move.y;
            }
        }
    }, {
        key: 'seResizeImage',
        value: function seResizeImage(move) {
            var lastImage = this.lastImage();
            if (lastImage) {
                // lastImage.x = lastImage.x + move.x;
                // lastImage.y = lastImage.y + move.y;
                lastImage.width = lastImage.width + move.x;
                lastImage.height = lastImage.height + move.y;
            }
        }
    }, {
        key: 'swResizeImage',
        value: function swResizeImage(move) {
            var lastImage = this.lastImage();
            if (lastImage) {
                lastImage.x = lastImage.x + move.x;
                // lastImage.y = lastImage.y + move.y;
                lastImage.width = lastImage.width - move.x;
                lastImage.height = lastImage.height + move.y;
            }
        }
    }, {
        key: 'undo',
        value: function undo() {
            if (this.goodEvents.length) {
                this.undoEvents.push(this.goodEvents.pop()); // {}
                this.undoEvents.push(this.goodEvents.pop()); // {type: 'line', point: [...], ...} or {type: 'image', image: {...}, ...}
                this.goodEvents.push({});
            }
        }
    }, {
        key: 'redo',
        value: function redo() {
            if (this.undoEvents.length) {
                this.goodEvents.pop();
                this.goodEvents.push(this.undoEvents.pop()); // {type: 'line', point: [...], ...} or {type: 'image', image: {...}, ...}
                this.goodEvents.push(this.undoEvents.pop()); // {}
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.goodEvents = [];
            this.undoEvents = [];
        }
    }]);

    return EventStore;
}();

exports.default = EventStore;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(9);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventStream = function () {
    function EventStream() {
        _classCallCheck(this, EventStream);

        this.emitter = new _events2.default();
    }

    _createClass(EventStream, [{
        key: "on",
        value: function on(name, listener) {
            this.emitter.on(name, listener);
        }
    }, {
        key: "selectLayer",
        value: function selectLayer(layer) {
            this.emitter.emit('selectLayer', layer);
        }
    }, {
        key: "addLayer",
        value: function addLayer() {
            this.emitter.emit('addLayer');
        }
    }, {
        key: "startDrawing",
        value: function startDrawing(x, y) {
            this.emitter.emit('start', { x: x, y: y });
        }
    }, {
        key: "stopDrawing",
        value: function stopDrawing() {
            this.emitter.emit('stop');
        }
    }, {
        key: "changeStrokeWidth",
        value: function changeStrokeWidth(width) {
            var change = { key: 'strokeWidth', value: width };
            this.emitter.emit('set', change);
        }
    }, {
        key: "changeStrokeColor",
        value: function changeStrokeColor(color) {
            var change = { key: 'strokeColor', value: color };
            this.emitter.emit('set', change);
        }
    }, {
        key: "pushPoint",
        value: function pushPoint(x, y) {
            var point = { x: x, y: y };
            this.emitter.emit('push', point);
        }
    }, {
        key: "pasteImage",
        value: function pasteImage(x, y, width, height, dataUrl) {
            var image = { x: x, y: y, width: width, height: height, dataUrl: dataUrl };
            this.emitter.emit('paste', image);
        }
    }, {
        key: "startDragging",
        value: function startDragging() {
            this.emitter.emit('startDragging');
        }
    }, {
        key: "stopDragging",
        value: function stopDragging() {
            this.emitter.emit('stopDragging');
        }
    }, {
        key: "dragImage",
        value: function dragImage(x, y) {
            var move = { x: x, y: y };
            this.emitter.emit('drag', move);
        }
    }, {
        key: "startResizing",
        value: function startResizing(resizeType) {
            this.emitter.emit('startResizing', resizeType);
        }
    }, {
        key: "stopResizing",
        value: function stopResizing() {
            this.emitter.emit('stopResizing');
        }
    }, {
        key: "resizeImage",
        value: function resizeImage(x, y) {
            var move = { x: x, y: y };
            this.emitter.emit('resize', move);
        }
    }, {
        key: "undo",
        value: function undo() {
            this.emitter.emit('undo');
        }
    }, {
        key: "redo",
        value: function redo() {
            this.emitter.emit('redo');
        }
    }, {
        key: "clear",
        value: function clear() {
            this.emitter.emit('clear');
        }
    }]);

    return EventStream;
}();

exports.default = EventStream;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SvgConverter = function () {
    function SvgConverter() {
        _classCallCheck(this, SvgConverter);
    }

    _createClass(SvgConverter, null, [{
        key: 'toSvgData',
        value: function toSvgData(sourceNode) {
            var htmlText = sourceNode.outerHTML;
            var base64EncodedText = window.btoa(window.encodeURIComponent(htmlText).replace(/%([0-9A-F]{2})/g, function (match, p1) {
                return String.fromCharCode(window.parseInt('0x' + p1));
            }));

            return new Promise(function (resolve) {
                resolve('data:image/svg+xml;charset=utf-8;base64,' + base64EncodedText);
            });
        }
    }, {
        key: 'toPngData',
        value: function toPngData(sourceNode) {
            return SvgConverter.toDataUrl(sourceNode, 'image/png');
        }
    }, {
        key: 'toJpegData',
        value: function toJpegData(sourceNode) {
            return SvgConverter.toDataUrl(sourceNode, 'image/jpeg');
        }
    }, {
        key: 'toDataUrl',
        value: function toDataUrl(sourceNode, imageType) {
            return new Promise(function (resolve) {
                SvgConverter.toSvgData(sourceNode).then(function (svgdata) {
                    var _sourceNode$getBoundi = sourceNode.getBoundingClientRect(),
                        width = _sourceNode$getBoundi.width,
                        height = _sourceNode$getBoundi.height;

                    var imageNode = new window.Image();
                    imageNode.onload = function () {
                        var canvasNode = document.createElement('canvas');
                        canvasNode.width = width;
                        canvasNode.height = height;

                        var graphicsContext = canvasNode.getContext('2d');
                        if (graphicsContext) {
                            graphicsContext.drawImage(imageNode, 0, 0);
                        } else {
                            throw new Error('got no rendering context');
                        }

                        resolve(canvasNode.toDataURL(imageType));
                    };
                    imageNode.src = svgdata;
                });
            });
        }
    }, {
        key: 'fromPngImage',
        value: function fromPngImage(imageUrl) {
            return SvgConverter.fromImageUrl(imageUrl, 'image/png');
        }
    }, {
        key: 'fromJpegImage',
        value: function fromJpegImage(imageUrl) {
            return SvgConverter.fromImageUrl(imageUrl, 'image/jpeg');
        }
    }, {
        key: 'fromGifImage',
        value: function fromGifImage(imageUrl) {
            return SvgConverter.fromImageUrl(imageUrl, 'image/gif');
        }
    }, {
        key: 'fromImageUrl',
        value: function fromImageUrl(imageUrl, imageType) {
            return new Promise(function (resolve) {
                var imageNode = new window.Image();
                imageNode.onload = function () {
                    var canvasNode = document.createElement('canvas');
                    canvasNode.width = imageNode.width;
                    canvasNode.height = imageNode.height;

                    var graphicsContext = canvasNode.getContext('2d');
                    if (graphicsContext) {
                        graphicsContext.drawImage(imageNode, 0, 0);
                    } else {
                        throw new Error('got no rendering context');
                    }

                    resolve({ width: imageNode.width, height: imageNode.height, dataUrl: canvasNode.toDataURL(imageType) });
                };
                imageNode.crossOrigin = 'anonymous';
                imageNode.src = imageUrl;
            });
        }
    }]);

    return SvgConverter;
}();

exports.default = SvgConverter;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Constants = __webpack_require__(0);

var Constants = _interopRequireWildcard(_Constants);

var _EventStream = __webpack_require__(2);

var _EventStream2 = _interopRequireDefault(_EventStream);

var _EventStore = __webpack_require__(1);

var _EventStore2 = _interopRequireDefault(_EventStore);

var _CursorPane = __webpack_require__(7);

var _CursorPane2 = _interopRequireDefault(_CursorPane);

var _CanvasPane = __webpack_require__(6);

var _CanvasPane2 = _interopRequireDefault(_CanvasPane);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Whiteboard = function (_React$Component) {
    _inherits(Whiteboard, _React$Component);

    function Whiteboard(props) {
        _classCallCheck(this, Whiteboard);

        var _this = _possibleConstructorReturn(this, (Whiteboard.__proto__ || Object.getPrototypeOf(Whiteboard)).call(this, props));

        _this.state = {
            eventStore: props.eventStore,
            mode: Constants.MODE.HAND,
            layer: 0,
            strokeWidth: 5,
            strokeColor: 'black'
        };

        _this.canvas = null;
        return _this;
    }

    _createClass(Whiteboard, [{
        key: 'getSvgElement',
        value: function getSvgElement() {
            if (this.canvas) {
                return this.canvas.getSvgElement();
            }
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.setupEventHandler();
        }
    }, {
        key: 'setupEventHandler',
        value: function setupEventHandler() {
            var _this2 = this;

            this.props.events.on('selectLayer', this.selectLayer.bind(this));
            this.props.events.on('addLayer', this.addLayer.bind(this));

            this.props.events.on('start', this.startDrawing.bind(this));
            this.props.events.on('stop', this.stopDrawing.bind(this));

            this.props.events.on('set', function (event) {
                if (event.key === 'strokeWidth') {
                    _this2.changeStrokeWidth(event.value);
                }
                if (event.key === 'strokeColor') {
                    _this2.changeStrokeColor(event.value);
                }
            });

            this.props.events.on('push', this.pushPoint.bind(this));

            this.props.events.on('paste', this.pasteImage.bind(this));
            this.props.events.on('startDragging', this.startDragging.bind(this));
            this.props.events.on('stopDragging', this.stopDragging.bind(this));
            this.props.events.on('drag', this.dragImage.bind(this));
            this.props.events.on('startResizing', this.startResizing.bind(this));
            this.props.events.on('stopResizing', this.stopResizing.bind(this));
            this.props.events.on('resize', this.resizeImage.bind(this));

            this.props.events.on('undo', this.undo.bind(this));
            this.props.events.on('redo', this.redo.bind(this));
            this.props.events.on('clear', this.clear.bind(this));
        }
    }, {
        key: 'selectLayer',
        value: function selectLayer(layer) {
            this.state.eventStore.selectLayer(layer);
            this.setState({
                layer: layer,
                eventStore: this.state.eventStore
            });
        }
    }, {
        key: 'addLayer',
        value: function addLayer() {
            this.state.eventStore.addLayer();
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'startDrawing',
        value: function startDrawing(point) {
            this.state.eventStore.startDrawing(this.state.strokeWidth, this.state.strokeColor, point);
            this.setState({
                mode: Constants.MODE.DRAW_LINE,
                eventStore: this.state.eventStore
            });
        }
    }, {
        key: 'stopDrawing',
        value: function stopDrawing() {
            this.state.eventStore.stopDrawing();
            this.setState({
                mode: Constants.MODE.HAND,
                eventStore: this.state.eventStore
            });
        }
    }, {
        key: 'changeStrokeWidth',
        value: function changeStrokeWidth(width) {
            this.state.eventStore.stopDrawing();
            this.setState({
                strokeWidth: width,
                eventStore: this.state.eventStore
            });
        }
    }, {
        key: 'changeStrokeColor',
        value: function changeStrokeColor(color) {
            this.state.eventStore.stopDrawing();
            this.setState({
                strokeColor: color,
                eventStore: this.state.eventStore
            });
        }
    }, {
        key: 'pushPoint',
        value: function pushPoint(point) {
            this.state.eventStore.pushPoint(this.state.strokeWidth, this.state.strokeColor, point);
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'pasteImage',
        value: function pasteImage(image) {
            this.state.eventStore.pasteImage(image);
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'startDragging',
        value: function startDragging() {
            this.setState({ mode: Constants.MODE.DRAG_IMAGE });
        }
    }, {
        key: 'stopDragging',
        value: function stopDragging() {
            this.setState({ mode: Constants.MODE.HAND });
        }
    }, {
        key: 'dragImage',
        value: function dragImage(move) {
            if (this.state.mode !== Constants.MODE.DRAG_IMAGE) {
                return;
            }

            this.state.eventStore.dragImage(move);
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'startResizing',
        value: function startResizing(resizeType) {
            this.setState({ mode: resizeType });
        }
    }, {
        key: 'stopResizing',
        value: function stopResizing() {
            this.setState({ mode: Constants.MODE.HAND });
        }
    }, {
        key: 'resizeImage',
        value: function resizeImage(move) {
            if (this.state.mode === Constants.MODE.NW_RESIZE_IMAGE) {
                this.state.eventStore.nwResizeImage(move);
                this.setState({ eventStore: this.state.eventStore });
            } else if (this.state.mode === Constants.MODE.NE_RESIZE_IMAGE) {
                this.state.eventStore.neResizeImage(move);
                this.setState({
                    eventStore: this.state.eventStore
                });
            } else if (this.state.mode === Constants.MODE.SE_RESIZE_IMAGE) {
                this.state.eventStore.seResizeImage(move);
                this.setState({
                    eventStore: this.state.eventStore
                });
            } else if (this.state.mode === Constants.MODE.SW_RESIZE_IMAGE) {
                this.state.eventStore.swResizeImage(move);
                this.setState({ eventStore: this.state.eventStore });
            }
        }
    }, {
        key: 'undo',
        value: function undo() {
            this.state.eventStore.undo();
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'redo',
        value: function redo() {
            this.state.eventStore.redo();
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.state.eventStore.clear();
            this.setState({ eventStore: this.state.eventStore });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var wrapperStyle = {
                position: 'relative',
                width: this.props.width,
                height: this.props.height
            };

            var props = Object.assign({}, this.props, this.state);

            return _react2.default.createElement(
                'div',
                { style: wrapperStyle },
                _react2.default.createElement(_CursorPane2.default, props),
                _react2.default.createElement(_CanvasPane2.default, _extends({ ref: function ref(canvas) {
                        return _this3.canvas = canvas;
                    } }, props))
            );
        }
    }]);

    return Whiteboard;
}(_react2.default.Component);

exports.default = Whiteboard;


Whiteboard.defaultProps = {
    events: new _EventStream2.default(),
    eventStore: new _EventStore2.default(),
    width: 400,
    height: 400,
    style: {
        backgroundColor: 'none'
    }
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Constants = __webpack_require__(0);

var Constants = _interopRequireWildcard(_Constants);

var _EventStore = __webpack_require__(1);

var _EventStore2 = _interopRequireDefault(_EventStore);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CanvasPane = function (_React$Component) {
    _inherits(CanvasPane, _React$Component);

    function CanvasPane(props) {
        _classCallCheck(this, CanvasPane);

        var _this = _possibleConstructorReturn(this, (CanvasPane.__proto__ || Object.getPrototypeOf(CanvasPane)).call(this, props));

        _this.svgElement = null;
        return _this;
    }

    _createClass(CanvasPane, [{
        key: 'getSvgElement',
        value: function getSvgElement() {
            return this.svgElement;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var canvasLayerStyle = {
                position: 'absolute',
                width: this.props.width,
                height: this.props.height
            };

            return _react2.default.createElement(
                'div',
                { style: canvasLayerStyle },
                _react2.default.createElement(
                    'svg',
                    { ref: function ref(element) {
                            return _this2.svgElement = element;
                        },
                        version: '1.1', xmlns: 'http://www.w3.org/2000/svg', xmlnsXlink: 'http://www.w3.org/1999/xlink',
                        width: this.props.width, height: this.props.height },
                    _react2.default.createElement('rect', { width: '100%', height: '100%', fill: this.props.style.backgroundColor }),
                    this.drawWhiteboardCanvas(),
                    this.drawImageBorder()
                )
            );
        }
    }, {
        key: 'drawWhiteboardCanvas',
        value: function drawWhiteboardCanvas() {
            return this.props.eventStore.reduceEvents().map(function (element, index) {
                if (element.type === Constants.SVG_ELEMENT_TYPE.LINE) {
                    var key = index;
                    var d = element.values.map(function (point, index) {
                        if (index === 0) {
                            return 'M ' + point.x + ' ' + point.y;
                        } else {
                            return 'L ' + point.x + ' ' + point.y;
                        }
                    });

                    return _react2.default.createElement('path', { key: key, d: d.join(' '), fill: 'none', stroke: element.strokeColor, strokeWidth: element.strokeWidth });
                } else if (element.type === Constants.SVG_ELEMENT_TYPE.IMAGE) {
                    var _key = index;
                    var image = element.image;

                    return _react2.default.createElement('image', { key: _key, x: image.x, y: image.y, width: image.width, height: image.height, xlinkHref: image.dataUrl });
                } else {
                    return null;
                }
            });
        }
    }, {
        key: 'drawImageBorder',
        value: function drawImageBorder() {
            var lastImage = this.props.eventStore.lastImage();
            if (!lastImage) {
                return null;
            }

            return _react2.default.createElement('rect', { x: lastImage.x, y: lastImage.y, width: lastImage.width, height: lastImage.height,
                fill: 'none', stroke: 'black', strokeDasharray: '5,5' });
        }
    }]);

    return CanvasPane;
}(_react2.default.Component);

exports.default = CanvasPane;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(3);

var _react2 = _interopRequireDefault(_react);

var _Constants = __webpack_require__(0);

var Constants = _interopRequireWildcard(_Constants);

var _EventStream = __webpack_require__(2);

var _EventStream2 = _interopRequireDefault(_EventStream);

var _EventStore = __webpack_require__(1);

var _EventStore2 = _interopRequireDefault(_EventStore);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CursorPane = function (_React$Component) {
    _inherits(CursorPane, _React$Component);

    function CursorPane(props) {
        _classCallCheck(this, CursorPane);

        var _this = _possibleConstructorReturn(this, (CursorPane.__proto__ || Object.getPrototypeOf(CursorPane)).call(this, props));

        _this.state = {
            dragStart: null,
            resizeStart: null
        };
        return _this;
    }

    _createClass(CursorPane, [{
        key: 'onClickCursorLayer',
        value: function onClickCursorLayer(ev) {
            var _this2 = this;

            var eventToPoint = function eventToPoint(ev) {
                var x = ev.nativeEvent.offsetX - 2;
                var y = ev.nativeEvent.offsetY + 2 * (_this2.props.strokeWidth / 3);
                return [x, y];
            };

            if (this.props.mode === Constants.MODE.HAND) {
                var _props$events;

                (_props$events = this.props.events).startDrawing.apply(_props$events, _toConsumableArray(eventToPoint(ev)));
            } else {
                this.props.events.stopDrawing();
            }
        }
    }, {
        key: 'onMouseMoveCursorLayer',
        value: function onMouseMoveCursorLayer(ev) {
            var _this3 = this;

            var eventToPoint = function eventToPoint(ev) {
                var x = ev.nativeEvent.offsetX - 2;
                var y = ev.nativeEvent.offsetY + 2 * (_this3.props.strokeWidth / 3);
                return [x, y];
            };

            if (this.props.mode === Constants.MODE.DRAW_LINE) {
                var _props$events2;

                (_props$events2 = this.props.events).pushPoint.apply(_props$events2, _toConsumableArray(eventToPoint(ev)));
            } else if (this.props.mode === Constants.MODE.DRAG_IMAGE) {
                if (ev.target !== this.dragHandle) {
                    return;
                }

                var lastImage = this.props.eventStore.lastImage();
                if (!lastImage) {
                    return;
                }

                if (this.state.dragStart) {
                    var base = lastImage.width < lastImage.height ? lastImage.width : lastImage.height;
                    var unit = base / 8 < 20 ? Math.ceil(base / 8) : 20;

                    var moveX = lastImage.x + unit < 0 ? ev.nativeEvent.offsetX - this.state.dragStart.x - (lastImage.x + unit) : ev.nativeEvent.offsetX - this.state.dragStart.x;
                    var moveY = lastImage.y + unit < 0 ? ev.nativeEvent.offsetY - this.state.dragStart.y - (lastImage.y + unit) : ev.nativeEvent.offsetY - this.state.dragStart.y;

                    this.props.events.dragImage(moveX, moveY);
                }
            } else if (this.props.mode === Constants.MODE.NW_RESIZE_IMAGE || this.props.mode === Constants.MODE.NE_RESIZE_IMAGE || this.props.mode === Constants.MODE.SE_RESIZE_IMAGE || this.props.mode === Constants.MODE.SW_RESIZE_IMAGE) {
                var _lastImage = this.props.eventStore.lastImage();
                if (!_lastImage) {
                    return;
                }

                if (this.state.resizeStart) {
                    var _moveX = ev.pageX - this.state.resizeStart.x;
                    var _moveY = ev.pageY - this.state.resizeStart.y;

                    // do nothing if cannot resize image
                    if (this.props.mode === Constants.MODE.NW_RESIZE_IMAGE && (_lastImage.width - _moveX < 0 || _lastImage.height - _moveY < 0)) {
                        return;
                    } else if (this.props.mode === Constants.MODE.NE_RESIZE_IMAGE && (_lastImage.width + _moveX < 0 || _lastImage.height - _moveY < 0)) {
                        return;
                    } else if (this.props.mode === Constants.MODE.SE_RESIZE_IMAGE && (_lastImage.width + _moveX < 0 || _lastImage.height + _moveY < 0)) {
                        return;
                    } else if (this.props.mode === Constants.MODE.SW_RESIZE_IMAGE && (_lastImage.width - _moveX < 0 || _lastImage.height + _moveY < 0)) {
                        return;
                    }

                    this.setState({ resizeStart: { x: ev.pageX, y: ev.pageY } });
                    this.props.events.resizeImage(_moveX, _moveY);
                }
            }
        }
    }, {
        key: 'onClickDragHandle',
        value: function onClickDragHandle(ev) {
            if (this.props.mode === Constants.MODE.HAND) {
                this.setState({ dragStart: { x: ev.nativeEvent.offsetX, y: ev.nativeEvent.offsetY } });
                this.props.events.startDragging();
            } else {
                this.setState({ dragStart: null });
                this.props.events.stopDragging();
            }
            ev.preventDefault();
            ev.stopPropagation();
        }
    }, {
        key: 'onClickResizeHandle',
        value: function onClickResizeHandle(resizeType, ev) {
            if (this.props.mode === Constants.MODE.HAND) {
                this.setState({ resizeStart: { x: ev.pageX, y: ev.pageY } });
                this.props.events.startResizing(resizeType);
            } else {
                this.setState({ resizeStart: null });
                this.props.events.stopResizing();
            }
            ev.preventDefault();
            ev.stopPropagation();
        }
    }, {
        key: 'render',
        value: function render() {
            var cursorLayerStyle = {
                position: 'absolute',
                zIndex: 2000,
                width: this.props.width,
                height: this.props.height,
                borderStyle: 'none none solid none',
                borderColor: this.props.strokeColor
            };

            return _react2.default.createElement(
                'div',
                { role: 'presentation', style: cursorLayerStyle,
                    onClick: this.onClickCursorLayer.bind(this), onMouseMove: this.onMouseMoveCursorLayer.bind(this) },
                this.renderImageHandle()
            );
        }
    }, {
        key: 'renderImageHandle',
        value: function renderImageHandle() {
            var _this4 = this;

            var lastImage = this.props.eventStore.lastImage();
            if (!lastImage) {
                return null;
            }

            var base = lastImage.width < lastImage.height ? lastImage.width : lastImage.height;
            var unit = base / 8 < 20 ? Math.ceil(base / 8) : 20;

            var mathMinOrMax = function mathMinOrMax(min, max, value) {
                if (value < min) {
                    return min;
                } else if (value > max) {
                    return max;
                } else {
                    return value;
                }
            };

            var top = mathMinOrMax(0, this.props.height, lastImage.y + unit);
            var bottom = mathMinOrMax(0, this.props.height, lastImage.y + lastImage.height - unit);
            var left = mathMinOrMax(0, this.props.width, lastImage.x + unit);
            var right = mathMinOrMax(0, this.props.width, lastImage.x + lastImage.width - unit);

            var dragHandleStyle = {
                position: 'absolute',
                zIndex: 2500,
                top: top,
                left: left,
                width: right - left,
                height: bottom - top,
                cursor: 'move'
            };

            var nwResizeHandleStyle = {
                position: 'absolute',
                zIndex: 2500,
                top: mathMinOrMax(0, this.props.height, top - unit),
                left: mathMinOrMax(0, this.props.width, left - unit),
                width: left - mathMinOrMax(0, this.props.width, left - unit),
                height: top - mathMinOrMax(0, this.props.height, top - unit),
                cursor: 'nw-resize'
            };

            var neResizeHandleStyle = {
                position: 'absolute',
                zIndex: 2500,
                top: mathMinOrMax(0, this.props.height, top - unit),
                left: right,
                width: mathMinOrMax(0, this.props.width, right + unit) - right,
                height: top - mathMinOrMax(0, this.props.height, top - unit),
                cursor: 'ne-resize'
            };

            var seResizeHandleStyle = {
                position: 'absolute',
                zIndex: 2500,
                top: bottom,
                left: right,
                width: mathMinOrMax(0, this.props.width, right + unit) - right,
                height: mathMinOrMax(0, this.props.height, bottom + unit) - bottom,
                cursor: 'se-resize'
            };

            var swResizeHandleStyle = {
                position: 'absolute',
                zIndex: 2500,
                top: bottom,
                left: mathMinOrMax(0, this.props.width, left - unit),
                width: left - mathMinOrMax(0, this.props.width, left - unit),
                height: mathMinOrMax(0, this.props.height, bottom + unit) - bottom,
                cursor: 'sw-resize'
            };

            return [_react2.default.createElement('div', { key: 'drag', role: 'presentation', style: dragHandleStyle,
                ref: function ref(dragHandle) {
                    return _this4.dragHandle = dragHandle;
                }, onClick: this.onClickDragHandle.bind(this) }), _react2.default.createElement('div', { key: 'nw-resize', role: 'presentation', style: nwResizeHandleStyle,
                onClick: this.onClickResizeHandle.bind(this, Constants.MODE.NW_RESIZE_IMAGE) }), _react2.default.createElement('div', { key: 'ne-resize', role: 'presentation', style: neResizeHandleStyle,
                onClick: this.onClickResizeHandle.bind(this, Constants.MODE.NE_RESIZE_IMAGE) }), _react2.default.createElement('div', { key: 'se-resize', role: 'presentation', style: seResizeHandleStyle,
                onClick: this.onClickResizeHandle.bind(this, Constants.MODE.SE_RESIZE_IMAGE) }), _react2.default.createElement('div', { key: 'sw-resize', role: 'presentation', style: swResizeHandleStyle,
                onClick: this.onClickResizeHandle.bind(this, Constants.MODE.SW_RESIZE_IMAGE) })];
        }
    }]);

    return CursorPane;
}(_react2.default.Component);

exports.default = CursorPane;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Whiteboard = __webpack_require__(5);

var _Whiteboard2 = _interopRequireDefault(_Whiteboard);

var _EventStream = __webpack_require__(2);

var _EventStream2 = _interopRequireDefault(_EventStream);

var _EventStore = __webpack_require__(1);

var _EventStore2 = _interopRequireDefault(_EventStore);

var _SvgConverter = __webpack_require__(4);

var _SvgConverter2 = _interopRequireDefault(_SvgConverter);

var _Constants = __webpack_require__(0);

var Constants = _interopRequireWildcard(_Constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
    Whiteboard: _Whiteboard2.default,
    EventStream: _EventStream2.default,
    EventStore: _EventStore2.default,
    SvgConverter: _SvgConverter2.default,
    Constants: Constants
};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map